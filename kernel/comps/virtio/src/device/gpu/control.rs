/* READ BEFORE CODING! */
/// Control implement some structs of different operations.
/// All structs are public here, BUT attributes are all private.
/// If later development needs a direct access to attributes, please add public functions in control.rs,
/// or directly set the attributes to public.
use bitflags::bitflags;
use ostd::Pod;
use super::header::{VirtioGPUCtrlHdr, VirtioGPUCtrlType};

pub const VIRTIO_GPU_MAX_SCANOUTS: usize = 16;

#[repr(C)]
#[derive(Debug, Clone, Copy, Default, PartialEq, Eq, Pod)]
pub struct VirtioGpuRect {
    x: u32, // 起始点的 X 坐标
    y: u32, // 起始点的 Y 坐标
    width: u32, // 矩形的宽度
    height: u32, // 矩形的高度
}

/// VIRTIO_GPU_CMD_GET_DISPLAY_INFO
/// 
/// Retrieve the current output configuration. No request data (just bare struct virtio_gpu_ctrl_hdr). 
/// Response type is VIRTIO_GPU_RESP_OK_DISPLAY_INFO, response data is struct virtio_gpu_resp_display_info.
#[repr(C)]
#[derive(Debug, Clone, Copy, Pod)]
pub struct VirtioGPUDisplayOne {
    r: VirtioGpuRect,
    // set when user enabled the display
    enable: u32,
    flags: u32,
}

#[repr(C)]
#[derive(Debug, Clone, Copy, Pod)]
pub struct VirtioGPURespDisplayInfo {
    hdr: VirtioGPUCtrlHdr,
    pmodes: [VirtioGPUDisplayOne; VIRTIO_GPU_MAX_SCANOUTS],
}

// TODO: functions of Display Info....



/// VIRTIO_GPU_CMD_GET_EDID: Retrieve the EDID data for a given scanout. 
/// 
/// Request data is struct virtio_gpu_get_edid). 
/// Response type is VIRTIO_GPU_RESP_OK_EDID, response data is struct virtio_gpu_resp_edid. 
/// Support is optional and negotiated using the VIRTIO_GPU_F_EDID feature flag.
#[repr(C)]
#[derive(Debug, Clone, Copy, Pod)]
pub struct VirtioGPUGetEdid {
    hdr: VirtioGPUCtrlHdr,
    scanout: u32,
    padding: u32
}

#[repr(C)]
#[derive(Debug, Clone, Copy, Pod)]
pub struct VirtioGPURespEdid {
    hdr: VirtioGPUCtrlHdr,
    size: u32,
    padding: u32,
    edid: [u8; 1024]
}





/// VIRTIO_GPU_CMD_RESOURCE_CREATE_2D: Create a 2D resource on the host. 
/// 
/// Request data is struct virtio_gpu_resource_create_2d. 
/// Response type is VIRTIO_GPU_RESP_OK_NODATA.
#[repr(u32)]
#[derive(Copy, Clone, Debug, PartialEq, Eq)]
#[allow(non_camel_case_types)]
pub enum VirtioGPUFormats {
    VIRTIO_GPU_FORMAT_B8G8R8A8_UNORM = 1,           // TODO: add annotations!
    VIRTIO_GPU_FORMAT_B8G8R8X8_UNORM  = 2,
    VIRTIO_GPU_FORMAT_A8R8G8B8_UNORM  = 3,
    VIRTIO_GPU_FORMAT_X8R8G8B8_UNORM  = 4,
    VIRTIO_GPU_FORMAT_R8G8B8A8_UNORM  = 67,
    VIRTIO_GPU_FORMAT_X8B8G8R8_UNORM  = 68,
    VIRTIO_GPU_FORMAT_A8B8G8R8_UNORM  = 121,
    VIRTIO_GPU_FORMAT_R8G8B8X8_UNORM  = 134,
}

/// This creates a 2D resource on the host with the specified width, height and format. 
/// The resource ids are generated by the guest.
#[repr(C)]
#[derive(Debug, Clone, Copy, Pod)]
pub struct VirtioGPUResourceCreate2d {
    hdr: VirtioGPUCtrlHdr,
    resource_id: u32,
    format: u32,                // enum from VirtioGPUFormats
    width: u32,
    height: u32
}

impl VirtioGPUResourceCreate2d {
    pub fn new(resource_id: u32, format: VirtioGPUFormats, width: u32, height: u32) -> Self {
        VirtioGPUResourceCreate2d {
            hdr: VirtioGPUCtrlHdr::from_type(VirtioGPUCtrlType::VIRTIO_GPU_CMD_RESOURCE_CREATE_2D),
            resource_id,
            format: format as u32,
            width,
            height,
        }
    }
}


/// VIRTIO_GPU_CMD_RESOURCE_UNREF: Destroy a resource. 
/// 
/// Request data is struct virtio_gpu_resource_unref. 
/// Response type is VIRTIO_GPU_RESP_OK_NODATA.
#[repr(C)]
#[derive(Debug, Clone, Copy, Pod)]
pub struct VirtioGPUResourceUnref {
    hdr: VirtioGPUCtrlHdr,
    resouce_id: u32,
    padding: u32,
}

/// VIRTIO_GPU_CMD_SET_SCANOUT: Set the scanout parameters for a single output. 
/// 
/// Request data is struct virtio_gpu_set_scanout. 
/// Response type is VIRTIO_GPU_RESP_OK_NODATA.
#[repr(C)]
#[derive(Debug, Clone, Copy, Pod)]
pub struct VirtioGPUSetScanout {
    hdr: VirtioGPUCtrlHdr,
    r: VirtioGpuRect,
    scanout_id: u32,
    resource_id: u32,
}

/// VIRTIO_GPU_CMD_RESOURCE_FLUSH: Flush a scanout resource.
/// 
/// Request data is struct virtio_gpu_resource_flush. 
/// Response type is VIRTIO_GPU_RESP_OK_NODATA.
#[repr(C)]
#[derive(Debug, Clone, Copy, Pod)]
pub struct VirtioGPUResourceFlush {
    hdr: VirtioGPUCtrlHdr,
    r: VirtioGpuRect,
    resource_id: u32,
    padding: u32,
}

/// VIRTIO_GPU_CMD_TRANSFER_TO_HOST_2D: Transfer from guest memory to host resource. 
/// 
/// Request data is struct virtio_gpu_transfer_to_host_2d. 
/// Response type is VIRTIO_GPU_RESP_OK_NODATA.
#[repr(C)]
#[derive(Debug, Clone, Copy, Pod)]
pub struct VirtioGPUTransferToHost2d {
    hdr: VirtioGPUCtrlHdr,
    r: VirtioGpuRect,
    offset: u64,
    resource_id: u32,
    padding: u32,
}

/// VIRTIO_GPU_CMD_RESOURCE_ATTACH_BACKING: Assign backing pages to a resource. 
/// 
/// Request data is struct virtio_gpu_resource_attach_backing, followed by struct virtio_gpu_mem_entry entries. 
/// Response type is VIRTIO_GPU_RESP_OK_NODATA.
#[repr(C)]
#[derive(Debug, Clone, Copy, Pod)]
pub struct VirtioGPUResourceAttachBacking {
    hdr: VirtioGPUCtrlHdr,
    resource_id: u32,
    nr_entries: u32
}

#[repr(C)]
#[derive(Debug, Clone, Copy, Pod)]
pub struct VirtioGPUMemEntry {
    addr: u64,
    length: u32,
    padding: u32
}

/// VIRTIO_GPU_CMD_RESOURCE_DETACH_BACKING
#[repr(C)]
#[derive(Debug, Clone, Copy, Pod)]
pub struct VirtioGPUResourceDetachBacking {
    hdr: VirtioGPUCtrlHdr,
    resource_id: u32,
    padding: u32,
}

/// VIRTIO_GPU_CMD_GET_CAPSET_INFO
#[repr(u32)]
#[derive(Copy, Clone, Debug, PartialEq, Eq)]
#[allow(non_camel_case_types)]
pub enum CapsetIndex {
    VIRTIO_GPU_CAPSET_VIRGL = 1,
    VIRTIO_GPU_CAPSET_VIRGL2 = 2,
    VIRTIO_GPU_CAPSET_GFXSTREAM = 3,
    VIRTIO_GPU_CAPSET_VENUS = 4,
    VIRTIO_GPU_CAPSET_CROSS_DOMAIN = 5,
}

#[repr(C)]
#[derive(Debug, Clone, Copy, Pod)]
pub struct VirtioGPUGetCapsetInfo {
    hdr: VirtioGPUCtrlHdr,
    capset_index: u32,              // from enum CapsetIndex
    padding: u32,
}

#[repr(C)]
#[derive(Debug, Clone, Copy, Pod)]
pub struct VirtioGPURespCapsetInfo {
    hdr: VirtioGPUCtrlHdr,
    capset_id: u32,                 // from enum CapsetIndex
    capset_max_version: u32,
    capset_max_size: u32,
    padding: u32,
}

// VIRTIO_GPU_CMD_GET_CAPSET
#[repr(C)]
#[derive(Debug, Clone, Copy, Pod)]
pub struct VirtioGPUGetCapset {
    hdr: VirtioGPUCtrlHdr,
    capset_id: u32,
    capset_version: u32,
}

#[repr(C)]
#[derive(Debug)]   // capset data doesn't have fixed size, unabling Clone, Copy and Pod
pub struct VirtioGPURespCapset {
    hdr: VirtioGPUCtrlHdr,
    capset_data: [u8],
}



/// VIRTIO_GPU_CMD_RESOURCE_ASSIGN_UUID
#[repr(C)]
#[derive(Debug, Clone, Copy, Pod)]
pub struct VirtioGPUResourceAssignUuid {
    hdr: VirtioGPUCtrlHdr,
    resource_id: u32,
    padding: u32,
}

#[repr(C)]
#[derive(Debug, Clone, Copy, Pod)]
pub struct VirtioGPURespResourceUuid {
    hdr: VirtioGPUCtrlHdr,
    uuid: [u8; 16],
}



// VIRTIO_GPU_CMD_RESOURCE_CREATE_BLOB
bitflags! {
    pub struct BlobMem: u32 {
        const VIRTIO_GPU_BLOB_MEM_GUEST = 1 << 0;
        const VIRTIO_GPU_BLOB_MEM_HOST3D = 1 << 1;
    }

    pub struct BlobFlags: u32 {
        const VIRTIO_GPU_BLOB_FLAG_USE_MAPPABLE = 1 << 0;
        const VIRTIO_GPU_BLOB_FLAG_USE_SHAREABLE = 1 << 1;
        const VIRTIO_GPU_BLOB_FLAG_USE_CROSS_DEVICE = 1 << 2;
    }
}

#[repr(C)]
#[derive(Debug, Clone, Copy, Pod)]
pub struct VirtioGPUResourceCreateBlob {
    hdr: VirtioGPUCtrlHdr,
    resource_id: u32,
    blob_mem: u32,        // use BlobMem (enable flags of guest and host 3d)
    blob_flags: u32,
    nr_entries: u32,
    blob_id: u64,
    size: u64,
}

/// VIRTIO_GPU_CMD_SET_SCANOUT_BLOB
#[repr(C)]
#[derive(Debug, Clone, Copy, Pod)]
pub struct VirtioGPUSetScanoutBlob {
    hdr: VirtioGPUCtrlHdr,
    r: VirtioGpuRect,
    scanout_id: u32,
    resource_id: u32,
    width: u32,
    height: u32,
    format: u32,        // from enum virtio_gpu_formats
    padding: u32,
    strides: [u32; 4],
    offsets: [u32; 4],
}

