/* READ BEFORE CODING! */
/// Control implement some structs of different operations.
/// All structs are public here, BUT attributes are all private.
/// If later development needs a direct access to attributes, please add public functions in control.rs,
/// or directly set the attributes to public.

/* AWARE: NO error detection yet!!!!!! */
/// But I think it should be implemented in device.rs 
/// (i.e. 由顶层模块检测错误并向 host 发送错误信息，而 control 模块只负责包装消息并发送)

use bitflags::bitflags;
use ostd::Pod;
use super::header::{VirtioGPUCtrlHdr, VirtioGPUCtrlType};

pub const VIRTIO_GPU_MAX_SCANOUTS: usize = 16;

#[repr(C)]
#[derive(Debug, Clone, Copy, Default, PartialEq, Eq, Pod)]
pub struct VirtioGPURect {
    pub x: u32, // 起始点的 X 坐标
    pub y: u32, // 起始点的 Y 坐标
    pub width: u32, // 矩形的宽度
    pub height: u32, // 矩形的高度
}

impl VirtioGPURect {
    pub fn new(x: u32, y: u32, width: u32, height: u32) -> Self {
        VirtioGPURect{x, y, width, height}
    }
}

/// VIRTIO_GPU_CMD_GET_DISPLAY_INFO
/// 
/// Retrieve the current output configuration. No request data (just bare struct virtio_gpu_ctrl_hdr). 
/// Response type is VIRTIO_GPU_RESP_OK_DISPLAY_INFO, response data is struct virtio_gpu_resp_display_info.
#[repr(C, packed)]
#[derive(Debug, Clone, Copy, Pod)]
pub struct VirtioGPUDisplayOne {
    pub r: VirtioGPURect,
    // set when user enabled the display
    pub enable: u32,
    pub flags: u32,
}

#[repr(C, packed)]
#[derive(Debug, Clone, Copy, Pod)]
pub struct VirtioGPURespDisplayInfo {
    hdr: VirtioGPUCtrlHdr,
    pmodes: [VirtioGPUDisplayOne; VIRTIO_GPU_MAX_SCANOUTS],
}
impl Default for VirtioGPURespDisplayInfo {
    fn default() -> Self {
        VirtioGPURespDisplayInfo {
            hdr: VirtioGPUCtrlHdr::default(),
            pmodes: [VirtioGPUDisplayOne {
                r: VirtioGPURect {
                    x: 0,
                    y: 0,
                    width: 0,
                    height: 0,
                },
                enable: 0,
                flags: 0,
            }; VIRTIO_GPU_MAX_SCANOUTS],
        }
    }
}
impl VirtioGPURespDisplayInfo {
    pub fn get_type(&self) -> u32 {
        self.hdr.ctrl_type
    }
    pub fn get_rect(&self, p: usize) -> Option<VirtioGPURect> {
        Some(self.pmodes[p].r)
    }
}
/// VIRTIO_GPU_CMD_GET_EDID: Retrieve the EDID data for a given scanout. 
/// 
/// Request data is struct virtio_gpu_get_edid). 
/// Response type is VIRTIO_GPU_RESP_OK_EDID, response data is struct virtio_gpu_resp_edid. 
/// Support is optional and negotiated using the VIRTIO_GPU_F_EDID feature flag.
#[repr(C, packed)]
#[derive(Debug, Clone, Copy, Pod)]
pub struct VirtioGPUGetEdid {
    hdr: VirtioGPUCtrlHdr,
    scanout: u32,           // 显示设备的编号
    padding: u32            // 多余填充字段，默认为0
}
impl Default for VirtioGPUGetEdid {
    fn default() -> Self {
        VirtioGPUGetEdid {
            hdr: VirtioGPUCtrlHdr::from_type(VirtioGPUCtrlType::VIRTIO_GPU_CMD_GET_EDID),
            scanout: 0,
            padding: 0,
        }
    }
}
impl VirtioGPUGetEdid {
    pub fn new(scanout: u32, padding: u32) -> Self {
        VirtioGPUGetEdid {
            hdr: VirtioGPUCtrlHdr::from_type(VirtioGPUCtrlType::VIRTIO_GPU_CMD_GET_EDID),
            scanout,
            padding
        }
    }
}

#[repr(C, packed)]
#[derive(Debug, Clone, Copy, Pod)]
pub struct VirtioGPURespEdid {
    hdr: VirtioGPUCtrlHdr,
    size: u32,
    padding: u32,
    edid: [u8; 1024]
}
impl Default for VirtioGPURespEdid {
    fn default() -> Self {
        VirtioGPURespEdid {
            hdr: VirtioGPUCtrlHdr::default(),
            size: 0,
            padding: 0,
            edid: [0; 1024],
        }
    }
}
impl VirtioGPURespEdid {
    pub fn get_type(&self) -> u32 {
        self.hdr.ctrl_type
    }
}
/// VIRTIO_GPU_CMD_RESOURCE_CREATE_2D: Create a 2D resource on the host. 
/// 
/// Request data is struct virtio_gpu_resource_create_2d. 
/// Response type is VIRTIO_GPU_RESP_OK_NODATA.
#[repr(u32)]
#[derive(Copy, Clone, Debug, PartialEq, Eq)]
#[allow(non_camel_case_types)]
pub enum VirtioGPUFormats {
    VIRTIO_GPU_FORMAT_B8G8R8A8_UNORM = 1,           // TODO: add annotations!
    VIRTIO_GPU_FORMAT_B8G8R8X8_UNORM  = 2,
    VIRTIO_GPU_FORMAT_A8R8G8B8_UNORM  = 3,
    VIRTIO_GPU_FORMAT_X8R8G8B8_UNORM  = 4,
    VIRTIO_GPU_FORMAT_R8G8B8A8_UNORM  = 67,
    VIRTIO_GPU_FORMAT_X8B8G8R8_UNORM  = 68,
    VIRTIO_GPU_FORMAT_A8B8G8R8_UNORM  = 121,
    VIRTIO_GPU_FORMAT_R8G8B8X8_UNORM  = 134,
}

/// This creates a 2D resource on the host with the specified width, height and format. 
/// The resource ids are generated by the guest.
#[repr(C, packed)]
#[derive(Debug, Clone, Copy, Pod, Default)]
pub struct VirtioGPUResourceCreate2D {
    pub hdr: VirtioGPUCtrlHdr,
    pub resource_id: u32,
    pub format: u32,
    pub width: u32,
    pub height: u32,
}

impl VirtioGPUResourceCreate2D {
    pub fn new(resource_id: u32, format: VirtioGPUFormats, width: u32, height: u32) -> Self {
        VirtioGPUResourceCreate2D {
            hdr: VirtioGPUCtrlHdr::from_type(VirtioGPUCtrlType::VIRTIO_GPU_CMD_RESOURCE_CREATE_2D),
            resource_id,
            format: format as u32,
            width,
            height,
        }
    }
}

#[repr(C, packed)]
#[derive(Debug, Clone, Copy, Pod)]
pub struct VirtioGPURespResourceCreate2D {
    pub hdr: VirtioGPUCtrlHdr,
}

impl VirtioGPURespResourceCreate2D {
    pub fn get_type(&self) -> u32 {
        self.hdr.ctrl_type
    }
}

impl Default for VirtioGPURespResourceCreate2D {
    fn default() -> Self {
        VirtioGPURespResourceCreate2D {
            hdr: VirtioGPUCtrlHdr::default(),
        }
    }
}

/// VIRTIO_GPU_CMD_RESOURCE_UNREF: Destroy a resource. 
/// 
/// Request data is struct virtio_gpu_resource_unref. 
/// Response type is VIRTIO_GPU_RESP_OK_NODATA.
#[repr(C, packed)]
#[derive(Debug, Clone, Copy, Pod)]
pub struct VirtioGPUResourceUnref {
    hdr: VirtioGPUCtrlHdr,
    resource_id: u32,
    padding: u32,
}

impl VirtioGPUResourceUnref {
    pub fn new(resource_id: u32, padding: u32) -> Self {
        VirtioGPUResourceUnref {
            hdr: VirtioGPUCtrlHdr::from_type(VirtioGPUCtrlType::VIRTIO_GPU_CMD_RESOURCE_CREATE_2D),
            resource_id, padding
        }
    }
}

/// VIRTIO_GPU_CMD_SET_SCANOUT: Set the scanout parameters for a single output. 
/// 
/// Request data is struct virtio_gpu_set_scanout. 
/// Response type is VIRTIO_GPU_RESP_OK_NODATA.
#[repr(C, packed)]
#[derive(Debug, Clone, Copy, Pod)]
pub struct VirtioGPUSetScanout {
    hdr: VirtioGPUCtrlHdr,
    r: VirtioGPURect,
    scanout_id: u32,
    resource_id: u32,
}

impl VirtioGPUSetScanout {
    pub fn new(scanout_id: u32, resource_id: u32, rect: VirtioGPURect) -> Self {
        VirtioGPUSetScanout {
            hdr: VirtioGPUCtrlHdr::from_type(VirtioGPUCtrlType::VIRTIO_GPU_CMD_SET_SCANOUT),
            scanout_id,
            resource_id,
            r: rect,
        }
    }
}

/// VIRTIO_GPU_CMD_RESOURCE_ATTACH_BACKING: Assign backing pages to a resource. 
/// 
/// Request data is struct virtio_gpu_resource_attach_backing, followed by struct virtio_gpu_mem_entry entries. 
/// Response type is VIRTIO_GPU_RESP_OK_NODATA.
#[repr(C, packed)]
#[derive(Debug, Clone, Copy, Pod)]
pub struct VirtioGPUResourceAttachBacking {
    hdr: VirtioGPUCtrlHdr,
    resource_id: u32,
    nr_entries: u32
}

impl VirtioGPUResourceAttachBacking {
    pub fn new(resource_id: u32, nr_entries: u32) -> Self {
        VirtioGPUResourceAttachBacking {
            hdr: VirtioGPUCtrlHdr::from_type(VirtioGPUCtrlType::VIRTIO_GPU_CMD_RESOURCE_ATTACH_BACKING),
            resource_id,
            nr_entries,
        }
    }
}

#[repr(C, packed)]
#[derive(Default, Debug, Clone, Copy, Pod)]
pub struct VirtioGPUMemEntry {
    addr: u64,
    length: u32,
    padding: u32
}

impl VirtioGPUMemEntry {
    pub(crate) fn new(addr: usize, length: u32) -> VirtioGPUMemEntry {
        VirtioGPUMemEntry {
            addr: addr as u64,
            length,
            padding: 0,
        }
    }
}
/// VIRTIO_GPU_CMD_RESOURCE_DETACH_BACKING
#[repr(C, packed)]
#[derive(Debug, Clone, Copy, Pod)]
pub struct VirtioGPUResourceDetachBacking {
    hdr: VirtioGPUCtrlHdr,
    resource_id: u32,
    padding: u32,
}

impl VirtioGPUResourceDetachBacking {
    pub fn new(resource_id: u32, padding: u32) -> Self {
        VirtioGPUResourceDetachBacking {
            hdr: VirtioGPUCtrlHdr::from_type(VirtioGPUCtrlType::VIRTIO_GPU_CMD_RESOURCE_DETACH_BACKING),
            resource_id,
            padding,
        }
    }
}

/// VIRTIO_GPU_CMD_GET_CAPSET_INFO
#[repr(u32)]
#[derive(Copy, Clone, Debug, PartialEq, Eq)]
#[allow(non_camel_case_types)]
pub enum CapsetIndex {
    VIRTIO_GPU_CAPSET_VIRGL = 1,
    VIRTIO_GPU_CAPSET_VIRGL2 = 2,
    VIRTIO_GPU_CAPSET_GFXSTREAM = 3,
    VIRTIO_GPU_CAPSET_VENUS = 4,
    VIRTIO_GPU_CAPSET_CROSS_DOMAIN = 5,
}

#[repr(C, packed)]
#[derive(Debug, Clone, Copy, Pod)]
pub struct VirtioGPUGetCapsetInfo {
    hdr: VirtioGPUCtrlHdr,
    capset_index: u32,              // from enum CapsetIndex
    padding: u32,
}

impl VirtioGPUGetCapsetInfo {
    pub fn new(capset_index: CapsetIndex, padding: u32) -> Self {
        VirtioGPUGetCapsetInfo {
            hdr: VirtioGPUCtrlHdr::from_type(VirtioGPUCtrlType::VIRTIO_GPU_CMD_GET_CAPSET_INFO),
            capset_index: capset_index as u32,
            padding,
        }
    }
}

#[repr(C, packed)]
#[derive(Debug, Clone, Copy, Pod)]
pub struct VirtioGPURespCapsetInfo {
    hdr: VirtioGPUCtrlHdr,
    capset_id: u32,                 // from enum CapsetIndex
    capset_max_version: u32,
    capset_max_size: u32,
    padding: u32,
}

// TODO: impl VirtioGPURespCapsetInfo

// VIRTIO_GPU_CMD_GET_CAPSET
#[repr(C, packed)]
#[derive(Debug, Clone, Copy, Pod)]
pub struct VirtioGPUGetCapset {
    hdr: VirtioGPUCtrlHdr,
    capset_id: u32,
    capset_version: u32,
}

impl VirtioGPUGetCapset {
    pub fn new(capset_id: u32, capset_version: u32) -> Self {
        VirtioGPUGetCapset {
            hdr: VirtioGPUCtrlHdr::from_type(VirtioGPUCtrlType::VIRTIO_GPU_CMD_GET_CAPSET),
            capset_id,
            capset_version,
        }
    }
}

/// VIRTIO_GPU_CMD_RESOURCE_ASSIGN_UUID
#[repr(C, packed)]
#[derive(Debug, Clone, Copy, Pod)]
pub struct VirtioGPUResourceAssignUuid {
    hdr: VirtioGPUCtrlHdr,
    resource_id: u32,
    padding: u32,
}

impl VirtioGPUResourceAssignUuid {
    pub fn new(resource_id: u32, padding: u32) -> Self {
        VirtioGPUResourceAssignUuid {
            hdr: VirtioGPUCtrlHdr::from_type(VirtioGPUCtrlType::VIRTIO_GPU_CMD_RESOURCE_ASSIGN_UUID),
            resource_id,
            padding,
        }
    }
}

#[repr(C, packed)]
#[derive(Debug, Clone, Copy, Pod)]
pub struct VirtioGPURespResourceUuid {
    hdr: VirtioGPUCtrlHdr,
    uuid: [u8; 16],
}

// TODO: impl VirtioGPURespResourceUuid

// VIRTIO_GPU_CMD_RESOURCE_CREATE_BLOB
bitflags! {
    pub struct BlobMem: u32 {
        const VIRTIO_GPU_BLOB_MEM_GUEST = 1 << 0;
        const VIRTIO_GPU_BLOB_MEM_HOST3D = 1 << 1;
    }

    pub struct BlobFlags: u32 {
        const VIRTIO_GPU_BLOB_FLAG_USE_MAPPABLE = 1 << 0;
        const VIRTIO_GPU_BLOB_FLAG_USE_SHAREABLE = 1 << 1;
        const VIRTIO_GPU_BLOB_FLAG_USE_CROSS_DEVICE = 1 << 2;
    }
}

#[repr(C, packed)]
#[derive(Debug, Clone, Copy, Pod)]
pub struct VirtioGPUResourceCreateBlob {
    hdr: VirtioGPUCtrlHdr,
    resource_id: u32,
    blob_mem: u32,        // use BlobMem (enable flags of guest and host 3d)
    blob_flags: u32,
    nr_entries: u32,
    blob_id: u64,
    size: u64,
}

impl VirtioGPUResourceCreateBlob {
    pub fn new(
        resource_id: u32,
        blob_mem: BlobMem,
        blob_flags: BlobFlags,
        nr_entries: u32,
        blob_id: u64,
        size: u64,
    ) -> Self {
        VirtioGPUResourceCreateBlob {
            hdr: VirtioGPUCtrlHdr::from_type(VirtioGPUCtrlType::VIRTIO_GPU_CMD_RESOURCE_CREATE_BLOB),
            resource_id,
            blob_mem: blob_mem.bits(),
            blob_flags: blob_flags.bits(),
            nr_entries,
            blob_id,
            size,
        }
    }
}

/// VIRTIO_GPU_CMD_SET_SCANOUT_BLOB
#[repr(C, packed)]
#[derive(Debug, Clone, Copy, Pod)]
pub struct VirtioGPUSetScanoutBlob {
    hdr: VirtioGPUCtrlHdr,
    r: VirtioGPURect,
    scanout_id: u32,
    resource_id: u32,
    width: u32,
    height: u32,
    format: u32,        // from enum virtio_gpu_formats
    padding: u32,
    strides: [u32; 4],
    offsets: [u32; 4],
}

impl VirtioGPUSetScanoutBlob {
    pub fn new(
        scanout_id: u32,
        resource_id: u32,
        width: u32,
        height: u32,
        format: u32,
        padding: u32,
        rect: VirtioGPURect,
        strides: [u32; 4],
        offsets: [u32; 4],
    ) -> Self {
        VirtioGPUSetScanoutBlob {
            hdr: VirtioGPUCtrlHdr::from_type(VirtioGPUCtrlType::VIRTIO_GPU_CMD_SET_SCANOUT_BLOB),
            r: rect,
            scanout_id,
            resource_id,
            width,
            height,
            format,
            padding,
            strides,
            offsets,
        }
    }
}

#[repr(C, packed)]
#[derive(Debug, Clone, Copy, Pod)]
pub struct VirtioGPURespSetScanout {
    hdr: VirtioGPUCtrlHdr,
}

impl VirtioGPURespSetScanout {
    pub fn get_type(&self) -> u32 {
        self.hdr.ctrl_type
    }
}

impl Default for VirtioGPURespSetScanout {
    fn default() -> Self {
        VirtioGPURespSetScanout {
            hdr: VirtioGPUCtrlHdr::default(),
        }
    }
}

#[repr(C, packed)]
#[derive(Debug, Clone, Copy, Pod)]
pub struct VirtioGPURespAttachBacking {
    hdr: VirtioGPUCtrlHdr,
}

impl VirtioGPURespAttachBacking {
    pub fn get_type(&self) -> u32 {
        self.hdr.ctrl_type
    }
}

impl Default for VirtioGPURespAttachBacking {
    fn default() -> Self {
        VirtioGPURespAttachBacking {
            hdr: VirtioGPUCtrlHdr::default(),
        }
    }
}

#[repr(C, packed)]
#[derive(Debug, Clone, Copy, Pod)]
pub(crate) struct VirtioGPUTransferToHost2D {
    hdr: VirtioGPUCtrlHdr,
    r: VirtioGPURect,
    offset: u64,
    resource_id: u32,
    padding: u32,
}

impl VirtioGPUTransferToHost2D {
    pub fn new(r: VirtioGPURect,
        offset: u64,
        resource_id: u32,
    ) -> VirtioGPUTransferToHost2D {
        VirtioGPUTransferToHost2D {
            hdr: VirtioGPUCtrlHdr::from_type(VirtioGPUCtrlType::VIRTIO_GPU_CMD_TRANSFER_TO_HOST_2D),
            r,
            offset,
            resource_id,
            padding: 0,
        }
    }
}

#[repr(C, packed)]
#[derive(Debug, Clone, Copy, Pod)]
pub struct VirtioGPURespTransferToHost2D {
    hdr: VirtioGPUCtrlHdr,
}
impl VirtioGPURespTransferToHost2D {
    pub fn get_type(&self) -> u32 {
        self.hdr.ctrl_type
    }
}
impl Default for VirtioGPURespTransferToHost2D {
    fn default() -> Self {
        VirtioGPURespTransferToHost2D {
            hdr: VirtioGPUCtrlHdr::default(),
        }
    }
}

#[repr(C, packed)]
#[derive(Debug, Clone, Copy, Pod)]
pub(crate) struct VirtioGPUResourceFlush {
    hdr: VirtioGPUCtrlHdr,
    r: VirtioGPURect,
    resource_id: u32,
    padding: u32,
}
impl VirtioGPUResourceFlush {
    pub(crate) fn new(r: VirtioGPURect, resource_id: u32) -> VirtioGPUResourceFlush {
        VirtioGPUResourceFlush {
            hdr: VirtioGPUCtrlHdr::from_type(VirtioGPUCtrlType::VIRTIO_GPU_CMD_RESOURCE_FLUSH),
            r,
            resource_id,
            padding: 0,
        }
    }
}

#[repr(C, packed)]
#[derive(Debug, Clone, Copy, Pod)]
pub struct VirtioGPURespResourceFlush {
    hdr: VirtioGPUCtrlHdr,
}
impl VirtioGPURespResourceFlush {
    pub fn get_type(&self) -> u32 {
        self.hdr.ctrl_type
    }
}
impl Default for VirtioGPURespResourceFlush {
    fn default() -> Self {
        VirtioGPURespResourceFlush {
            hdr: VirtioGPUCtrlHdr::default(),
        }
    }
}

#[repr(C, packed)]
#[derive(Debug, Clone, Copy, Pod)]
pub(crate) struct VirtioGPUCursorPos {
    scanout_id: u32,
    x: u32,
    y: u32,
    padding: u32,
}
impl VirtioGPUCursorPos {
    pub(crate) fn new(scanout_id: u32, x: u32, y: u32) -> VirtioGPUCursorPos {
        VirtioGPUCursorPos {scanout_id, x, y, padding: 0}
    }
}

#[repr(C, packed)]
#[derive(Debug, Clone, Copy, Pod)]
pub(crate) struct VirtioGPUUpdateCursor {
    hdr: VirtioGPUCtrlHdr,
    pos: VirtioGPUCursorPos,
    resource_id: u32,
    hot_x: u32,
    hot_y: u32,
    padding: u32,
}
impl VirtioGPUUpdateCursor {
    pub(crate) fn new(
        pos: VirtioGPUCursorPos,
        resource_id: u32,
        hot_x: u32,
        hot_y: u32,
    ) -> VirtioGPUUpdateCursor {
        VirtioGPUUpdateCursor {
            hdr: VirtioGPUCtrlHdr::from_type(VirtioGPUCtrlType::VIRTIO_GPU_CMD_UPDATE_CURSOR),
            pos,
            resource_id,
            hot_x,
            hot_y,
            padding: 0,
        }
    }
}

#[repr(C, packed)]
#[derive(Debug, Clone, Copy, Pod)]
pub struct VirtioGPURespUpdateCursor {
    hdr: VirtioGPUCtrlHdr,
}
impl VirtioGPURespUpdateCursor {
    pub fn get_type(&self) -> u32 {
        self.hdr.ctrl_type
    }
}
impl Default for VirtioGPURespUpdateCursor {
    fn default() -> Self {
        VirtioGPURespUpdateCursor {
            hdr: VirtioGPUCtrlHdr::default(),
        }
    }
}