diff --git a/docs/src/kernel/linux-compatibility.md b/docs/src/kernel/linux-compatibility.md
index 026c9219..a11fb5b7 100644
--- a/docs/src/kernel/linux-compatibility.md
+++ b/docs/src/kernel/linux-compatibility.md
@@ -123,7 +123,7 @@ provided by Linux on x86-64 architecture.
 | 100     | times            | ❌              |
 | 101     | ptrace           | ❌              |
 | 102     | getuid           | ✅              |
-| 103     | syslog           | ❌              |
+| 103     | syslog           | ✅              |
 | 104     | getgid           | ✅              |
 | 105     | setuid           | ✅              |
 | 106     | setgid           | ✅              |
diff --git a/kernel/comps/logger/src/aster_logger.rs b/kernel/comps/logger/src/aster_logger.rs
index e92f15cd..160a197a 100644
--- a/kernel/comps/logger/src/aster_logger.rs
+++ b/kernel/comps/logger/src/aster_logger.rs
@@ -1,7 +1,19 @@
 // SPDX-License-Identifier: MPL-2.0
 
+use alloc::string::ToString;
 use log::{Metadata, Record};
-use ostd::timer::Jiffies;
+use ostd::{sync::SpinLock, timer::Jiffies};
+
+/// Callback function type for syslog integration
+pub type SyslogCallback = fn(level: log::Level, message: &str);
+
+/// Global syslog callback protected by spinlock
+static SYSLOG_CALLBACK: SpinLock<Option<SyslogCallback>> = SpinLock::new(None);
+
+/// Register a callback for syslog integration
+pub fn register_syslog_callback(callback: SyslogCallback) {
+    *SYSLOG_CALLBACK.lock() = Some(callback);
+}
 
 /// The logger used for Asterinas.
 struct AsterLogger;
@@ -15,6 +27,12 @@ impl log::Log for AsterLogger {
 
     fn log(&self, record: &Record) {
         let timestamp = Jiffies::elapsed().as_duration().as_secs_f64();
+        
+        // Add to syslog buffer if callback is registered
+        if let Some(callback) = *SYSLOG_CALLBACK.lock() {
+            callback(record.level(), &record.args().to_string());
+        }
+        
         print_logs(record, timestamp);
     }
 
diff --git a/kernel/comps/logger/src/lib.rs b/kernel/comps/logger/src/lib.rs
index 2423430e..1021adf0 100644
--- a/kernel/comps/logger/src/lib.rs
+++ b/kernel/comps/logger/src/lib.rs
@@ -22,6 +22,7 @@ mod aster_logger;
 mod console;
 
 pub use console::_print;
+pub use aster_logger::{register_syslog_callback, SyslogCallback};
 
 #[init_component]
 fn init() -> Result<(), ComponentInitError> {
diff --git a/kernel/src/lib.rs b/kernel/src/lib.rs
index fcdc1a81..7f5c5379 100644
--- a/kernel/src/lib.rs
+++ b/kernel/src/lib.rs
@@ -95,12 +95,13 @@ pub fn init() {
     thread::init();
     util::random::init();
     driver::init();
+    // Initialize time before filesystem since ramfs needs timestamps for inodes
     time::init();
-    #[cfg(target_arch = "x86_64")]
+    // Initialize rootfs before device::init() since device nodes need the filesystem
+    fs::rootfs::init(boot_info().initramfs.expect("No initramfs found!")).unwrap();
+    device::init();
     net::init();
     sched::init();
-    fs::rootfs::init(boot_info().initramfs.expect("No initramfs found!")).unwrap();
-    device::init().unwrap();
     syscall::init();
     vdso::init();
     process::init();
diff --git a/kernel/src/syscall/arch/riscv.rs b/kernel/src/syscall/arch/riscv.rs
index 5c5b74e4..4267b389 100644
--- a/kernel/src/syscall/arch/riscv.rs
+++ b/kernel/src/syscall/arch/riscv.rs
@@ -141,6 +141,7 @@ use super::{
     wait4::sys_wait4,
     waitid::sys_waitid,
     write::sys_write,
+    syslog::sys_syslog,
 };
 
 impl_syscall_nums_and_dispatch_fn! {
@@ -309,4 +310,5 @@ impl_syscall_nums_and_dispatch_fn! {
     SYS_CLOSE_RANGE = 436      => sys_close_range(args[..3]);
     SYS_FACCESSAT2 = 439         => sys_faccessat2(args[..4]);
     SYS_EPOLL_PWAIT2 = 441       => sys_epoll_pwait2(args[..5]);
+    SYS_SYSLOG = 116             => sys_syslog(args[..3]);
 }
diff --git a/kernel/src/syscall/arch/x86.rs b/kernel/src/syscall/arch/x86.rs
index 3a7117d6..c4c636ae 100644
--- a/kernel/src/syscall/arch/x86.rs
+++ b/kernel/src/syscall/arch/x86.rs
@@ -144,6 +144,7 @@ use super::{
     symlink::{sys_symlink, sys_symlinkat},
     sync::sys_sync,
     sysinfo::sys_sysinfo,
+    syslog::sys_syslog,
     tgkill::sys_tgkill,
     time::sys_time,
     timer_create::{sys_timer_create, sys_timer_delete},
@@ -255,6 +256,7 @@ impl_syscall_nums_and_dispatch_fn! {
     SYS_GETRUSAGE = 98         => sys_getrusage(args[..2]);
     SYS_SYSINFO = 99           => sys_sysinfo(args[..1]);
     SYS_GETUID = 102           => sys_getuid(args[..0]);
+    SYS_SYSLOG = 103           => sys_syslog(args[..3]);
     SYS_GETGID = 104           => sys_getgid(args[..0]);
     SYS_SETUID = 105           => sys_setuid(args[..1]);
     SYS_SETGID = 106           => sys_setgid(args[..1]);
diff --git a/kernel/src/syscall/mod.rs b/kernel/src/syscall/mod.rs
index 8c7c5d02..020a52bf 100644
--- a/kernel/src/syscall/mod.rs
+++ b/kernel/src/syscall/mod.rs
@@ -152,6 +152,7 @@ mod statx;
 mod symlink;
 mod sync;
 mod sysinfo;
+mod syslog;
 mod tgkill;
 mod time;
 mod timer_create;
@@ -389,6 +390,12 @@ macro_rules! log_syscall_entry {
     };
 }
 
+// Export the syslog function for external use
+pub use syslog::add_to_kernel_log;
+
 pub(super) fn init() {
     uname::init();
+    // Register syslog callback for kernel log buffer integration
+    // This is done after thread system initialization to ensure sync primitives work properly
+    aster_logger::register_syslog_callback(add_to_kernel_log);
 }
diff --git a/kernel/src/syscall/syslog.rs b/kernel/src/syscall/syslog.rs
new file mode 100644
index 00000000..90baeb07
--- /dev/null
+++ b/kernel/src/syscall/syslog.rs
@@ -0,0 +1,328 @@
+// SPDX-License-Identifier: MPL-2.0
+
+//! Syslog system call implementation for Asterinas
+//!
+//! This module provides a clean and simple implementation of the syslog system call
+//! that supports kernel log buffer operations compatible with Linux's klogctl/syslog interface.
+
+use alloc::{format, vec::Vec};
+use spin::Once;
+
+use ostd::sync::SpinLock;
+
+use super::SyscallReturn;
+use crate::{
+    prelude::*,
+    process::credentials::capabilities::CapSet,
+};
+
+/// Syslog action constants (compatible with Linux)
+const SYSLOG_ACTION_CLOSE: i32 = 0;
+const SYSLOG_ACTION_OPEN: i32 = 1;
+const SYSLOG_ACTION_READ: i32 = 2;
+const SYSLOG_ACTION_READ_ALL: i32 = 3;
+const SYSLOG_ACTION_READ_CLEAR: i32 = 4;
+const SYSLOG_ACTION_CLEAR: i32 = 5;
+const SYSLOG_ACTION_CONSOLE_OFF: i32 = 6;
+const SYSLOG_ACTION_CONSOLE_ON: i32 = 7;
+const SYSLOG_ACTION_CONSOLE_LEVEL: i32 = 8;
+const SYSLOG_ACTION_SIZE_UNREAD: i32 = 9;
+const SYSLOG_ACTION_SIZE_BUFFER: i32 = 10;
+
+/// Console log level constants
+const CONSOLE_LOGLEVEL_DEFAULT: i32 = 7;
+const CONSOLE_LOGLEVEL_MIN: i32 = 1;
+const CONSOLE_LOGLEVEL_MAX: i32 = 8;
+
+/// Kernel log buffer configuration
+const KERNEL_LOG_BUFFER_SIZE: usize = 65536; // 64KB buffer
+
+/// Efficient circular kernel log buffer using fixed-size array and pointers
+struct KernelLogBuffer {
+    /// Fixed-size buffer for log data
+    buffer: Vec<u8>,
+    /// Write position in the buffer (where next byte will be written)
+    write_pos: usize,
+    /// Read position for destructive reads
+    read_pos: usize,
+    /// Number of valid bytes in buffer (0 <= count <= buffer.len())
+    count: usize,
+    /// Total bytes written since buffer creation (for statistics)
+    total_written: usize,
+}
+
+impl KernelLogBuffer {
+    /// Create a new kernel log buffer
+    fn new() -> Self {
+        let mut buffer = Vec::with_capacity(KERNEL_LOG_BUFFER_SIZE);
+        buffer.resize(KERNEL_LOG_BUFFER_SIZE, 0);
+        Self {
+            buffer,
+            write_pos: 0,
+            read_pos: 0,
+            count: 0,
+            total_written: 0,
+        }
+    }
+
+    /// Add a log message to the buffer
+    fn append(&mut self, data: &[u8]) {
+        self.total_written += data.len();
+        
+        for &byte in data {
+            // Write byte at current write position
+            self.buffer[self.write_pos] = byte;
+            
+            // Advance write position (circular)
+            self.write_pos = (self.write_pos + 1) % self.buffer.len();
+            
+            // If buffer is not full, increase count
+            if self.count < self.buffer.len() {
+                self.count += 1;
+            } else {
+                // Buffer is full, we're overwriting old data
+                // Advance read position to maintain valid data range
+                self.read_pos = (self.read_pos + 1) % self.buffer.len();
+            }
+        }
+    }
+
+    /// Read data from buffer (destructive read, advances read pointer)
+    fn read_destructive(&mut self, buf: &mut [u8]) -> usize {
+        let unread_count = self.unread_count();
+        let to_read = core::cmp::min(buf.len(), unread_count);
+        
+        for i in 0..to_read {
+            // Calculate actual position in circular buffer
+            let pos = (self.read_pos + i) % self.buffer.len();
+            buf[i] = self.buffer[pos];
+        }
+        
+        // Update read position
+        self.read_pos = (self.read_pos + to_read) % self.buffer.len();
+        
+        to_read
+    }
+
+    /// Read all data from buffer (non-destructive)
+    fn read_all(&self, buf: &mut [u8]) -> usize {
+        let to_read = core::cmp::min(buf.len(), self.count);
+        
+        // Calculate the starting position for reading all data
+        let start_pos = if self.count < self.buffer.len() {
+            // Buffer not full yet, start from beginning
+            0
+        } else {
+            // Buffer is full, start from oldest data (write_pos)
+            self.write_pos
+        };
+        
+        for i in 0..to_read {
+            let pos = (start_pos + i) % self.buffer.len();
+            buf[i] = self.buffer[pos];
+        }
+        
+        to_read
+    }
+
+    /// Clear the buffer completely
+    fn clear(&mut self) {
+        self.write_pos = 0;
+        self.read_pos = 0;
+        self.count = 0;
+        // Don't reset total_written as it's cumulative statistics
+    }
+
+    /// Get size of unread data (data available for destructive read)
+    fn unread_size(&self) -> usize {
+        self.unread_count()
+    }
+    
+    /// Helper: calculate unread count for destructive reads
+    fn unread_count(&self) -> usize {
+        if self.count == 0 {
+            return 0;
+        }
+        
+        // Calculate distance from read_pos to write_pos
+        if self.write_pos >= self.read_pos {
+            core::cmp::min(self.write_pos - self.read_pos, self.count)
+        } else {
+            core::cmp::min(self.buffer.len() - self.read_pos + self.write_pos, self.count)
+        }
+    }
+
+    /// Get buffer capacity
+    fn buffer_size(&self) -> usize {
+        self.buffer.len()
+    }
+}
+
+/// Global kernel log buffer (lazily initialized)
+static KERNEL_LOG_BUFFER: Once<SpinLock<KernelLogBuffer>> = Once::new();
+
+/// Console log level
+static CONSOLE_LOG_LEVEL: SpinLock<i32> = SpinLock::new(CONSOLE_LOGLEVEL_DEFAULT);
+
+/// Get or initialize the kernel log buffer
+fn get_kernel_log_buffer() -> &'static SpinLock<KernelLogBuffer> {
+    KERNEL_LOG_BUFFER.call_once(|| SpinLock::new(KernelLogBuffer::new()))
+}
+
+/// Add a message to the kernel log buffer
+pub fn add_to_kernel_log(_level: log::Level, message: &str) {
+    let mut buffer = get_kernel_log_buffer().lock();
+    
+    // Format message with timestamp (similar to dmesg format)
+    let timestamp = ostd::timer::Jiffies::elapsed().as_duration().as_secs_f64();
+    let formatted = format!("[{:>10.6}] {}\n", timestamp, message);
+    
+    buffer.append(formatted.as_bytes());
+}
+
+/// Main syslog syscall implementation
+pub fn sys_syslog(action: i32, buf_ptr: Vaddr, len: i32, ctx: &Context) -> Result<SyscallReturn> {
+    debug!("syslog: action={}, buf_ptr=0x{:x}, len={}", action, buf_ptr, len);
+
+    // Check basic parameter validity
+    if len < 0 {
+        return_errno_with_message!(Errno::EINVAL, "negative buffer length");
+    }
+
+    match action {
+        SYSLOG_ACTION_CLOSE | SYSLOG_ACTION_OPEN => {
+            // These are no-ops in our implementation
+            Ok(SyscallReturn::Return(0))
+        }
+        
+        SYSLOG_ACTION_READ => {
+            check_syslog_permission(ctx)?;
+            if len == 0 {
+                return Ok(SyscallReturn::Return(0));
+            }
+            read_kernel_log(buf_ptr, len as usize, ctx, true)
+        }
+        
+        SYSLOG_ACTION_READ_ALL => {
+            check_syslog_permission(ctx)?;
+            if len == 0 {
+                return Ok(SyscallReturn::Return(0));
+            }
+            read_kernel_log(buf_ptr, len as usize, ctx, false)
+        }
+        
+        SYSLOG_ACTION_READ_CLEAR => {
+            check_syslog_permission(ctx)?;
+            if len == 0 {
+                clear_kernel_log();
+                return Ok(SyscallReturn::Return(0));
+            }
+            let bytes_read = read_kernel_log(buf_ptr, len as usize, ctx, false)?;
+            clear_kernel_log();
+            Ok(bytes_read)
+        }
+        
+        SYSLOG_ACTION_CLEAR => {
+            check_syslog_permission(ctx)?;
+            clear_kernel_log();
+            Ok(SyscallReturn::Return(0))
+        }
+        
+        SYSLOG_ACTION_CONSOLE_OFF => {
+            check_syslog_permission(ctx)?;
+            set_console_log_level(CONSOLE_LOGLEVEL_MIN)
+        }
+        
+        SYSLOG_ACTION_CONSOLE_ON => {
+            check_syslog_permission(ctx)?;
+            set_console_log_level(CONSOLE_LOGLEVEL_DEFAULT)
+        }
+        
+        SYSLOG_ACTION_CONSOLE_LEVEL => {
+            check_syslog_permission(ctx)?;
+            if len < CONSOLE_LOGLEVEL_MIN || len > CONSOLE_LOGLEVEL_MAX {
+                return_errno_with_message!(Errno::EINVAL, "invalid console log level");
+            }
+            set_console_log_level(len)
+        }
+        
+        SYSLOG_ACTION_SIZE_UNREAD => {
+            check_syslog_permission(ctx)?;
+            let size = get_unread_size();
+            Ok(SyscallReturn::Return(size as isize))
+        }
+        
+        SYSLOG_ACTION_SIZE_BUFFER => {
+            check_syslog_permission(ctx)?;
+            let size = get_buffer_size();
+            Ok(SyscallReturn::Return(size as isize))
+        }
+        
+        _ => return_errno_with_message!(Errno::EINVAL, "invalid syslog action"),
+    }
+}
+
+/// Check if the current process has permission to perform syslog operations
+fn check_syslog_permission(ctx: &Context) -> Result<()> {
+    let credentials = ctx.posix_thread.credentials();
+    let effective_caps = credentials.effective_capset();
+    
+    // Check for CAP_SYSLOG or CAP_SYS_ADMIN
+    if effective_caps.contains(CapSet::SYSLOG) || effective_caps.contains(CapSet::SYS_ADMIN) {
+        Ok(())
+    } else {
+        return_errno_with_message!(Errno::EPERM, "operation not permitted");
+    }
+}
+
+/// Read data from kernel log buffer
+fn read_kernel_log(buf_ptr: Vaddr, len: usize, ctx: &Context, destructive: bool) -> Result<SyscallReturn> {
+    if buf_ptr == 0 {
+        return_errno_with_message!(Errno::EFAULT, "null buffer pointer");
+    }
+
+    let mut temp_buf = vec![0u8; len];
+    let bytes_read = {
+        let mut buffer = get_kernel_log_buffer().lock();
+        if destructive {
+            buffer.read_destructive(&mut temp_buf)
+        } else {
+            buffer.read_all(&mut temp_buf)
+        }
+    };
+
+    if bytes_read > 0 {
+        // Copy data to user space
+        let user_space = ctx.user_space();
+        for (i, &byte) in temp_buf.iter().take(bytes_read).enumerate() {
+            user_space.write_val(buf_ptr + i, &byte)?;
+        }
+    }
+
+    Ok(SyscallReturn::Return(bytes_read as isize))
+}
+
+/// Clear the kernel log buffer
+fn clear_kernel_log() {
+    let mut buffer = get_kernel_log_buffer().lock();
+    buffer.clear();
+}
+
+/// Set console log level
+fn set_console_log_level(level: i32) -> Result<SyscallReturn> {
+    let mut console_level = CONSOLE_LOG_LEVEL.lock();
+    *console_level = level;
+    Ok(SyscallReturn::Return(0))
+}
+
+/// Get size of unread data in kernel log buffer
+fn get_unread_size() -> usize {
+    let buffer = get_kernel_log_buffer().lock();
+    buffer.unread_size()
+}
+
+/// Get total size of kernel log buffer
+fn get_buffer_size() -> usize {
+    let buffer = get_kernel_log_buffer().lock();
+    buffer.buffer_size()
+} 
\ No newline at end of file
diff --git a/ostd/src/cpu/local/dyn_cpu_local.rs b/ostd/src/cpu/local/dyn_cpu_local.rs
index da29376f..cb2598d8 100644
--- a/ostd/src/cpu/local/dyn_cpu_local.rs
+++ b/ostd/src/cpu/local/dyn_cpu_local.rs
@@ -74,24 +74,29 @@ impl<T> CpuLocal<T, DynamicStorage<T>> {
     /// The given `ptr` points to the variable located on the BSP.
     ///
     /// Please do not call this function directly. Instead, use
-    /// `DynCpuLocalChunk::alloc`.
+    /// [`DynCpuLocalChunk::alloc`].
     ///
     /// # Safety
     ///
-    /// The caller must ensure that the new per-CPU object belongs to an
-    /// existing [`DynCpuLocalChunk`], and does not overlap with any existing
-    /// CPU-local object.
+    /// The caller must ensure that
+    ///  - the new per-CPU object belongs to an existing
+    ///    [`DynCpuLocalChunk`], and does not overlap with any
+    ///    existing CPU-local object;
+    ///  - the `ITEM_SIZE` of the [`DynCpuLocalChunk`] satisfies
+    ///    the layout requirement of `T`.
     unsafe fn __new_dynamic(ptr: *mut T, init_values: &mut impl FnMut(CpuId) -> T) -> Self {
         let mut storage = DynamicStorage(NonNull::new(ptr).unwrap());
         for cpu in all_cpus() {
             let ptr = storage.get_mut_ptr_on_target(cpu);
-            // SAFETY: `ptr` points to valid, uninitialized per-CPU memory
-            // reserved for CPU-local storage. This initialization occurs
-            // before any other code can access the memory. References to
-            // the data may only be created after `Self` is created, ensuring
-            // exclusive access by the current task. Each per-CPU memory
-            // region is written exactly once using `ptr::write`, which is
-            // safe for uninitialized memory.
+            // SAFETY:
+            //  - `ptr` is valid for writes, because:
+            //    - The `DynCpuLocalChunk` slot is non-null and dereferenceable.
+            //    - This initialization occurs before any other code can access
+            //      the memory. References to the data may only be created
+            //      after `Self` is created, ensuring exclusive access by the
+            //      current task.
+            //  - `ptr` is properly aligned, as the caller guarantees that the
+            //    layout requirement is satisfied.
             unsafe {
                 core::ptr::write(ptr, init_values(cpu));
             }
@@ -159,8 +164,11 @@ impl<const ITEM_SIZE: usize> DynCpuLocalChunk<ITEM_SIZE> {
 
         let index = self.bitmap.first_zero()?;
         self.bitmap.set(index, true);
-        // SAFETY: `index` refers to an available position in the chunk
-        // for allocating a new CPU-local object.
+        // SAFETY:
+        //  - `index` refers to an available position in the chunk
+        //    for allocating a new CPU-local object.
+        //  - We have checked the size and alignment requirement
+        //    for `T` above.
         unsafe {
             let vaddr = self.start_vaddr() + index * ITEM_SIZE;
             Some(CpuLocal::__new_dynamic(vaddr as *mut T, init_values))
@@ -195,15 +203,22 @@ impl<const ITEM_SIZE: usize> DynCpuLocalChunk<ITEM_SIZE> {
         let Some(index) = self.get_item_index(&cpu_local) else {
             return Err(cpu_local);
         };
+
         self.bitmap.set(index, false);
         for cpu in all_cpus() {
             let ptr = cpu_local.storage.get_mut_ptr_on_target(cpu);
-            // SAFETY: `ptr` points to the valid CPU-local object. We can
-            // mutably borrow the CPU-local object on `cpu` because we have
-            // the exclusive access to `cpu_local`. Each CPU-local object
-            // is dropped exactly once. After the deallocation, no one will
-            // access the dropped CPU-local object, since we explicitly
-            // forget the `cpu_local`.
+            // SAFETY:
+            //  - `ptr` is valid for both reads and writes, because:
+            //    - The pointer of the CPU-local object on `cpu` is
+            //      non-null and dereferenceable.
+            //    - We can mutably borrow the CPU-local object on `cpu`
+            //      because we have the exclusive access to `cpu_local`.
+            //  - The pointer of the CPU-local object is properly aligned.
+            //  - The pointer of the CPU-local object points to a valid
+            //    instance of `T`.
+            //  - After the deallocation, no one will access the
+            //    dropped CPU-local object, since we explicitly forget
+            //    the `cpu_local`.
             unsafe {
                 core::ptr::drop_in_place(ptr);
             }
diff --git a/test/src/apps/Makefile b/test/src/apps/Makefile
index c4d82cdc..d0864417 100644
--- a/test/src/apps/Makefile
+++ b/test/src/apps/Makefile
@@ -37,6 +37,7 @@ TEST_APPS := \
 	pthread \
 	pty \
 	sched \
+	syslog \
 	shm \
 	vsock \
 
diff --git a/test/src/apps/syslog/Makefile b/test/src/apps/syslog/Makefile
new file mode 100644
index 00000000..9a664a9a
--- /dev/null
+++ b/test/src/apps/syslog/Makefile
@@ -0,0 +1,5 @@
+# SPDX-License-Identifier: MPL-2.0
+
+include ../test_common.mk
+
+EXTRA_C_FLAGS := 
\ No newline at end of file
diff --git a/test/src/apps/syslog/dmesg.c b/test/src/apps/syslog/dmesg.c
new file mode 100644
index 00000000..cb392433
--- /dev/null
+++ b/test/src/apps/syslog/dmesg.c
@@ -0,0 +1,83 @@
+// SPDX-License-Identifier: MPL-2.0
+
+// Simple dmesg implementation for Asterinas
+// Displays kernel ring buffer messages similar to Linux dmesg
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <sys/syscall.h>
+#include <errno.h>
+#include <string.h>
+
+// Syslog action constants
+#define SYSLOG_ACTION_READ_ALL      3
+#define SYSLOG_ACTION_CLEAR         5
+#define SYSLOG_ACTION_SIZE_BUFFER   10
+
+void print_usage(const char *progname) {
+    printf("Usage: %s [options]\n", progname);
+    printf("Display kernel ring buffer messages\n\n");
+    printf("Options:\n");
+    printf("  -c, --clear        Clear the ring buffer after printing\n");
+    printf("  -h, --help         Show this help message\n");
+}
+
+int main(int argc, char *argv[]) {
+    int clear_buffer = 0;
+    
+    // Parse command line arguments
+    for (int i = 1; i < argc; i++) {
+        if (strcmp(argv[i], "-c") == 0 || strcmp(argv[i], "--clear") == 0) {
+            clear_buffer = 1;
+        } else if (strcmp(argv[i], "-h") == 0 || strcmp(argv[i], "--help") == 0) {
+            print_usage(argv[0]);
+            return 0;
+        } else {
+            printf("Unknown option: %s\n", argv[i]);
+            print_usage(argv[0]);
+            return 1;
+        }
+    }
+    
+    // Get kernel log buffer size
+    long buffer_size = syscall(SYS_syslog, SYSLOG_ACTION_SIZE_BUFFER, NULL, 0);
+    if (buffer_size <= 0) {
+        fprintf(stderr, "dmesg: Unable to get kernel buffer size: %s\n", strerror(errno));
+        return 1;
+    }
+    
+    // Allocate buffer
+    char *buffer = malloc(buffer_size);
+    if (!buffer) {
+        fprintf(stderr, "dmesg: Cannot allocate memory\n");
+        return 1;
+    }
+    
+    // Read all kernel messages
+    long bytes_read = syscall(SYS_syslog, SYSLOG_ACTION_READ_ALL, buffer, buffer_size - 1);
+    if (bytes_read < 0) {
+        fprintf(stderr, "dmesg: Unable to read kernel buffer: %s\n", strerror(errno));
+        free(buffer);
+        return 1;
+    }
+    
+    // Print the messages
+    if (bytes_read > 0) {
+        buffer[bytes_read] = '\0';  // Ensure null termination
+        printf("%s", buffer);
+    }
+    
+    // Clear buffer if requested
+    if (clear_buffer) {
+        long result = syscall(SYS_syslog, SYSLOG_ACTION_CLEAR, NULL, 0);
+        if (result < 0) {
+            fprintf(stderr, "dmesg: Unable to clear kernel buffer: %s\n", strerror(errno));
+            free(buffer);
+            return 1;
+        }
+    }
+    
+    free(buffer);
+    return 0;
+} 
\ No newline at end of file
diff --git a/test/src/apps/syslog/syslog_test.c b/test/src/apps/syslog/syslog_test.c
new file mode 100644
index 00000000..322640e1
--- /dev/null
+++ b/test/src/apps/syslog/syslog_test.c
@@ -0,0 +1,276 @@
+// SPDX-License-Identifier: MPL-2.0
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <sys/syscall.h>
+#include <errno.h>
+#include <string.h>
+
+// Syslog action constants
+#define SYSLOG_ACTION_READ_ALL      3
+#define SYSLOG_ACTION_CLEAR         5
+#define SYSLOG_ACTION_SIZE_UNREAD   9
+#define SYSLOG_ACTION_SIZE_BUFFER   10
+
+// ============================================================================
+// Helper functions
+// ============================================================================
+
+#define THROW_ERROR(fmt, ...)                                                   \
+	do {                                                                    \
+		printf("\t\tERROR:" fmt                                         \
+		       " in func %s at line %d of file %s with errno %d: %s\n", \
+		       ##__VA_ARGS__, __func__, __LINE__, __FILE__, errno,      \
+		       strerror(errno));                                        \
+		return -1;                                                      \
+	} while (0)
+
+// ============================================================================
+// Test syslog buffer size
+// ============================================================================
+
+int test_syslog_buffer_size()
+{
+	printf("=== Testing syslog buffer size ===\n");
+	
+	long buffer_size = syscall(SYS_syslog, SYSLOG_ACTION_SIZE_BUFFER, NULL, 0);
+	if (buffer_size <= 0) {
+		THROW_ERROR("Failed to get kernel log buffer size");
+	}
+	
+	printf("✓ Kernel log buffer size: %ld bytes\n", buffer_size);
+	
+	// Sanity check: buffer size should be reasonable (typically 64KB to 16MB)
+	if (buffer_size < 1024 || buffer_size > 16 * 1024 * 1024) {
+		THROW_ERROR("Buffer size %ld seems unreasonable", buffer_size);
+	}
+	
+	printf("✓ Buffer size is within reasonable range\n");
+	return 0;
+}
+
+// ============================================================================
+// Test syslog unread size
+// ============================================================================
+
+int test_syslog_unread_size()
+{
+	printf("\n=== Testing syslog unread size ===\n");
+	
+	long unread_size = syscall(SYS_syslog, SYSLOG_ACTION_SIZE_UNREAD, NULL, 0);
+	if (unread_size < 0) {
+		THROW_ERROR("Failed to get unread data size");
+	}
+	
+	printf("✓ Unread data size: %ld bytes\n", unread_size);
+	
+	// Get buffer size for comparison
+	long buffer_size = syscall(SYS_syslog, SYSLOG_ACTION_SIZE_BUFFER, NULL, 0);
+	if (buffer_size <= 0) {
+		THROW_ERROR("Failed to get buffer size for comparison");
+	}
+	
+	// Unread size should not exceed buffer size
+	if (unread_size > buffer_size) {
+		THROW_ERROR("Unread size %ld exceeds buffer size %ld", unread_size, buffer_size);
+	}
+	
+	printf("✓ Unread size is within buffer limits\n");
+	return 0;
+}
+
+// ============================================================================
+// Test syslog read all
+// ============================================================================
+
+int test_syslog_read_all()
+{
+	printf("\n=== Testing syslog read all ===\n");
+	
+	// Get buffer size first
+	long buffer_size = syscall(SYS_syslog, SYSLOG_ACTION_SIZE_BUFFER, NULL, 0);
+	if (buffer_size <= 0) {
+		THROW_ERROR("Failed to get buffer size");
+	}
+	
+	// Allocate buffer for reading kernel messages
+	char *buffer = malloc(buffer_size + 1); // +1 for null terminator
+	if (!buffer) {
+		THROW_ERROR("Failed to allocate buffer of size %ld", buffer_size);
+	}
+	
+	printf("✓ Allocated buffer of %ld bytes\n", buffer_size);
+	
+	// Read all kernel messages
+	long bytes_read = syscall(SYS_syslog, SYSLOG_ACTION_READ_ALL, buffer, buffer_size);
+	if (bytes_read < 0) {
+		free(buffer);
+		THROW_ERROR("Failed to read kernel log");
+	}
+	
+	printf("✓ Read %ld bytes from kernel log\n", bytes_read);
+	
+	// Ensure null termination
+	if (bytes_read < buffer_size) {
+		buffer[bytes_read] = '\0';
+	} else {
+		buffer[buffer_size - 1] = '\0';
+	}
+	
+	if (bytes_read > 0) {
+		printf("✓ Successfully read kernel messages\n");
+		printf("--- First 200 characters of log (if available) ---\n");
+		
+		// Display first part of the log for verification
+		int display_len = (bytes_read < 200) ? bytes_read : 200;
+		for (int i = 0; i < display_len; i++) {
+			if (buffer[i] >= 32 && buffer[i] < 127) {
+				putchar(buffer[i]);
+			} else if (buffer[i] == '\n') {
+				putchar('\n');
+			} else {
+				putchar('.');
+			}
+		}
+		if (bytes_read > 200) {
+			printf("\n... (truncated, total %ld bytes)\n", bytes_read);
+		}
+		printf("--- End of log sample ---\n");
+	} else {
+		printf("✓ No kernel messages available (empty log)\n");
+	}
+	
+	free(buffer);
+	return 0;
+}
+
+// ============================================================================
+// Test syslog clear
+// ============================================================================
+
+int test_syslog_clear()
+{
+	printf("\n=== Testing syslog clear ===\n");
+	
+	// Get unread size before clearing
+	long unread_before = syscall(SYS_syslog, SYSLOG_ACTION_SIZE_UNREAD, NULL, 0);
+	if (unread_before < 0) {
+		THROW_ERROR("Failed to get unread size before clear");
+	}
+	
+	printf("✓ Unread size before clear: %ld bytes\n", unread_before);
+	
+	// Clear the log buffer
+	long result = syscall(SYS_syslog, SYSLOG_ACTION_CLEAR, NULL, 0);
+	if (result < 0) {
+		THROW_ERROR("Failed to clear kernel log buffer");
+	}
+	
+	printf("✓ Successfully cleared kernel log buffer\n");
+	
+	// Get unread size after clearing
+	long unread_after = syscall(SYS_syslog, SYSLOG_ACTION_SIZE_UNREAD, NULL, 0);
+	if (unread_after < 0) {
+		THROW_ERROR("Failed to get unread size after clear");
+	}
+	
+	printf("✓ Unread size after clear: %ld bytes\n", unread_after);
+	
+	// After clearing, unread size should be 0 or significantly reduced
+	if (unread_after > unread_before) {
+		THROW_ERROR("Unread size increased after clear (before: %ld, after: %ld)", 
+			   unread_before, unread_after);
+	}
+	
+	printf("✓ Clear operation appears successful\n");
+	return 0;
+}
+
+// ============================================================================
+// Test error handling
+// ============================================================================
+
+int test_syslog_error_handling()
+{
+	printf("\n=== Testing syslog error handling ===\n");
+	
+	// Test with invalid action
+	long result = syscall(SYS_syslog, 999, NULL, 0);
+	if (result >= 0) {
+		printf("⚠ Warning: Invalid action didn't return error (result: %ld)\n", result);
+	} else {
+		printf("✓ Invalid action properly returned error\n");
+	}
+	
+	// Test read with NULL buffer but non-zero size
+	result = syscall(SYS_syslog, SYSLOG_ACTION_READ_ALL, NULL, 100);
+	if (result >= 0) {
+		printf("⚠ Warning: NULL buffer with non-zero size didn't return error\n");
+	} else {
+		printf("✓ NULL buffer with non-zero size properly returned error\n");
+	}
+	
+	printf("✓ Error handling tests completed\n");
+	return 0;
+}
+
+// ============================================================================
+// Main test function
+// ============================================================================
+
+int main() {
+	printf("=== Syslog Comprehensive Test for Asterinas ===\n\n");
+	
+	int failed_tests = 0;
+	
+	// Run all tests
+	if (test_syslog_buffer_size() < 0) {
+		printf("❌ Buffer size test failed\n");
+		failed_tests++;
+	} else {
+		printf("✅ Buffer size test passed\n");
+	}
+	
+	if (test_syslog_unread_size() < 0) {
+		printf("❌ Unread size test failed\n");
+		failed_tests++;
+	} else {
+		printf("✅ Unread size test passed\n");
+	}
+	
+	if (test_syslog_read_all() < 0) {
+		printf("❌ Read all test failed\n");
+		failed_tests++;
+	} else {
+		printf("✅ Read all test passed\n");
+	}
+	
+	if (test_syslog_clear() < 0) {
+		printf("❌ Clear test failed\n");
+		failed_tests++;
+	} else {
+		printf("✅ Clear test passed\n");
+	}
+	
+	if (test_syslog_error_handling() < 0) {
+		printf("❌ Error handling test failed\n");
+		failed_tests++;
+	} else {
+		printf("✅ Error handling test passed\n");
+	}
+	
+	// Summary
+	printf("\n=== Test Summary ===\n");
+	printf("Total tests: 5\n");
+	printf("Passed: %d\n", 5 - failed_tests);
+	printf("Failed: %d\n", failed_tests);
+	
+	if (failed_tests == 0) {
+		printf("🎉 All syslog tests passed successfully!\n");
+		return 0;
+	} else {
+		printf("❌ Some tests failed. Please check the output above.\n");
+		return 1;
+	}
+} 
\ No newline at end of file
