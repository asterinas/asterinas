// SPDX-License-Identifier: MPL-2.0

use alloc::{boxed::Box, string::ToString};
use core::{
    any::Any,
    sync::atomic::{AtomicU64, Ordering},
};

use ktest::runner::KtestDependencies;

use crate::task::{Task, TaskOptions};

pub(super) fn run_ktests() -> ktest::runner::KtestResult {
    // The whitelists that will be generated by OSDK runner as static consts.
    extern "Rust" {
        static KTEST_TEST_WHITELIST: Option<&'static [&'static str]>;
        static KTEST_CRATE_WHITELIST: Option<&'static [&'static str]>;
    }

    let catch_unwind_fn = unwinding::panic::catch_unwind::<(), fn()>
        as fn(fn()) -> Result<(), Box<(dyn Any + Send + 'static)>>;

    crate::arch::timer::register_callback(timer_callback);

    let ktest_deps = KtestDependencies {
        print_fn: crate::console::print,
        catch_unwind_fn,
        monotonic_millis_fn: monotonic_millis,
        spawn_fn: |f| {
            let _ = TaskOptions::new(f).data(()).spawn();
        },
        yield_fn: Task::yield_now,
    };

    // SAFETY: validity of extern statics are guaranteed by the OSDK.
    unsafe {
        ktest::runner::run_ktests(
            &ktest_deps,
            KTEST_TEST_WHITELIST.map(|s| s.iter().map(|s| s.to_string())),
            KTEST_CRATE_WHITELIST,
        )
    }
}

static MILLIS: AtomicU64 = AtomicU64::new(0);

fn monotonic_millis() -> u64 {
    MILLIS.load(Ordering::Relaxed) * 1000 / crate::arch::timer::TIMER_FREQ
}

fn timer_callback() {
    MILLIS.fetch_add(1, Ordering::Relaxed);
}
