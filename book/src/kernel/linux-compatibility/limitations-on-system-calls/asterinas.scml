// Get the scheduling policy of a "normal" thread
sched_getattr(
    pid,
    attr = {
        sched_policy = SCHED_OTHER | SCHED_BATCH | SCHED_IDLE,
        sched_flags = 0,
        ..
    },
    flags = 0,
);
// Set the scheduling policy of a "normal" thread
sched_setattr(
    pid,
    attr = {
        sched_policy = SCHED_OTHER | SCHED_BATCH | SCHED_IDLE,
        sched_flags = 0,
        ..
    },
    flags = 0,
);

// Get the scheduling policy of a real-time thread
sched_getattr(
    pid,
    attr = {
        sched_policy = SCHED_FIFO | SCHED_RR,
        sched_flags = 0,
        ..
    },
    flags = 0,
);
// Set the scheduling policy of a real-time thread
sched_setattr(
    pid,
    attr = {
        sched_policy = SCHED_FIFO | SCHED_RR,
        sched_flags = 0,
        ..
    },
    flags = 0,
);

prot = PROT_NONE |
    PROT_EXEC |
    PROT_READ |
    PROT_WRITE;
opt_flags =
    MAP_ANONYMOUS |
    MAP_FIXED |
    MAP_FIXED_NOREPLACE |
    MAP_GROWSDOWN |
    MAP_HUGETLB |
    MAP_LOCKED |
    MAP_NONBLOCK |
    MAP_NORESERVE |
    MAP_POPULATE |
    MAP_SYNC;

// Create a private memory mapping
mmap(
    addr, length,
    prot = <prot>,
    flags = MAP_PRIVATE | <opt_flags>,
    fd, offset
);

// Create a shared memory mapping
mmap(
    addr, length,
    prot = <prot>,
    flags = MAP_SHARED | MAP_SHARED_VALIDATE | <opt_flags>,
    fd, offset
);

// Unmap a memory mapping
munmap(addr, length);

// Flush memory region to disk asynchronously
msync(
    addr, length,
    flags = MS_ASYNC | MS_INVALIDATE
);

// Flush memory region to disk synchronously
msync(
    addr, length,
    flags = MS_SYNC | MS_INVALIDATE
);

// Resize an existing memory mapping. Relocation is allowed if given `MREMAP_MAYMOVE`.
mremap(
    old_address,
    old_size,
    new_size,
    flags = MREMAP_MAYMOVE
);

// Resize an existing memory mapping and force relocation to a specified location.
mremap(
    old_address,
    old_size,
    new_size,
    flags = MREMAP_MAYMOVE | MREMAP_FIXED,
    new_address
);

// Set memory access permissions
mprotect(
    addr,
    len,
    prot = <prot>
);

// Apply the default memory access pattern with no special optimizations
madvise(addr, length, advice = MADV_NORMAL);

// Indicate sequential access to enable aggressive read-ahead and immediate page release
madvise(addr, length, advice = MADV_SEQUENTIAL);

// Prefetch pages for near-future access to reduce latency
madvise(addr, length, advice = MADV_WILLNEED);

access_mode =
    O_RDONLY |
    O_WRONLY |
    O_RDWR;
creation_flags =
    O_CLOEXEC |
    O_DIRECTORY |
    O_EXCL |
    O_NOCTTY |
    O_NOFOLLOW |
    O_TRUNC;
status_flags =
    O_APPEND |
    O_ASYNC |
    O_DIRECT |
    O_LARGEFILE |
    O_NOATIME |
    O_NONBLOCK |
    O_SYNC;

// Open an existing file
open(
    path,
    flags = <access_mode> | <creation_flags> | <status_flags>,
);
openat(
    dirfd,
    path,
    flags = <access_mode> | <creation_flags> | <status_flags>,
);

// Create a new file
open(
    path,
    flags = O_CREAT | <access_mode> | <creation_flags> | <status_flags>,
    mode
);
openat(
    dirfd,
    path,
    flags = O_CREAT | <access_mode> | <creation_flags> | <status_flags>,
    mode
);

// Status flags that are meaningful with O_PATH
opath_valid_flags = O_CLOEXEC | O_DIRECTORY | O_NOFOLLOW;
// All other flags are ignored with O_PATH
opath_ignored_flags = O_CREAT | <creation_flags> | <status_flags>;
// Obtain a file descriptor to indicate a location in FS
open(
    path,
    flags = O_PATH | <opath_valid_flags> | <opath_ignored_flags>
);
openat(
    dirfd,
    path,
    flags = O_PATH | <opath_valid_flags> | <opath_ignored_flags>
);

// Create an unnamed file
// open(path, flags = O_TMPFILE | <creation_flags> | <status_flags>)

// Create a new mount
mount(
    source, target, filesystemtype,
    mountflags = 0,
    data
);

// Move the existing mount point
mount(
    source, target, filesystemtype,
    mountflags = MS_MOVE,
    data
);

// Create a bind mount
mount(
    source, target, filesystemtype,
    mountflags = MS_BIND | MS_REC | MS_MOVE,
    data
);

// Unmount a mounted file system
umount(target);

// Unmount a mounted file system with enhanced behavior control
umount2(target, flags = UMOUNT_NOFOLLOW);

ignore_flags = O_RDONLY | O_WRONLY | O_RDWR | O_CREAT | O_EXCL | O_NOCTTY | O_TRUNC;
can_change_flags = O_APPEND | O_ASYNC | O_DIRECT | O_NOATIME | O_NONBLOCK;

// Duplicate a file descriptor
fcntl(fd, cmd = F_DUPFD | F_DUPFD_CLOEXEC, arg);

// Retrieve file descriptor flags (F_GETFD), file status flags (F_GETFL)
// or SIGIO/SIGURG owner process (F_GETOWN)
fcntl(fd, cmd = F_GETFD | F_GETFL | F_GETOWN);

// Set file descriptor flags
fcntl(fd, cmd = F_SETFD, arg = FD_CLOEXEC);

// Set file status flags
fcntl(fd, cmd = F_SETFL, arg = <ignore_flags> | <can_change_flags>);

// Manage record locks: test (F_GETLK), non-blocking set (F_SETLK), blocking set (F_SETLKW)
fcntl(fd, cmd = F_GETLK | F_SETLK | F_SETLKW, arg);

// Assign SIGIO/SIGURG owner process
fcntl(fd, cmd = F_SETOWN, arg);

// Create pipe
pipe(pipefd);

// Create pipe with enhanced behavior control
pipe2(pipefd, flags = O_CLOEXEC);

// Create event notification descriptor
eventfd(initval);

// Create event notification descriptor with enhanced behavior control
eventfd2(initval, flags = EFD_CLOEXEC);

// Creat or open a semaphore set
semget(
    key,
    nsems,
    semflg = IPC_CREAT | IPC_EXCL
);

struct sembuf = {
    sem_flg = IPC_NOWAIT,
    ..
};

// Semaphore operations without blocking
semop(
    semid,
    sops = [ <sembuf> ],
    nsops
);

// Remove the semaphore set
semctl(
    semid,
    semnum,
    cmd = IPC_RMID
);

// Initialize the value of the semnum-th semaphore
semctl(
    semid,
    semnum,
    cmd = SETVAL,
    arg
);

// Return the current value (GETVAL), last operating process's PID (GETPID),
// count of processes awaiting increment (GETNCNT) or count of processes awaiting
// zero (GETZCNT) of the semnum-th semaphore
semctl(
    semid,
    semnum,
    cmd = GETVAL | GETPID | GETNCNT | GETZCNT
);

// Retrieve a copy of the `semid_ds` kernel structure for the specified semaphore set
semctl(
    semid,
    semnum,
    cmd = IPC_STAT,
    arg
);

// Optional flags for socket type
opt_type_flags = SOCK_NONBLOCK | SOCK_CLOEXEC;

// Create a UNIX socket
socket(
    family = AF_UNIX,
    type = SOCK_STREAM | SOCK_SEQPACKET | <opt_type_flags>,
    protocol = 0
);

// Create an IPv4 socket (TCP or UDP)
socket(
    family = AF_INET,
    type = SOCK_STREAM | SOCK_DGRAM | <opt_type_flags>,
    protocol = IPPROTO_IP | IPPROTO_TCP | IPPROTO_UDP
);

// Create a netlink socket
socket(
    family = AF_NETLINK,
    type = SOCK_RAW | SOCK_DGRAM | <opt_type_flags>,
    protocol = NETLINK_ROUTE | NETLINK_KOBJECT_UEVENT
);

// Create a VSOCK socket
socket(
    family = AF_VSOCK,
    type = SOCK_STREAM | <opt_type_flags>,
    protocol = 0
);

// Change and/or retrieve a signal action
rt_sigaction(
    signum,
    act = {
        sa_flags = SA_ONSTACK | SA_RESTART | SA_NODEFER | SA_RESTORER | SA_SIGINFO | SA_RESETHAND,
        ..
    },
    oldact, sigsetsize
);

// Change and/or retrieve blocked signals
rt_sigprocmask(
    how = SIG_BLOCK | SIG_UNBLOCK | SIG_SETMASK, set, oldset, sigsetsize
);

opt_notify_methods = SIGEV_NONE | SIGEV_SIGNAL | SIGEV_THREAD_ID;

// Create a timer with predefined clock source
timer_create(
    clockid = CLOCK_PROCESS_CPUTIME_ID | CLOCK_THREAD_CPUTIME_ID | CLOCK_REALTIME | CLOCK_MONOTONIC | CLOCK_BOOTTIME,
    sevp = {
        sigev_notify = <opt_notify_methods>,
        ..
    },
    timerid
);

// Create a timer based on a per-process or per-thread clock
timer_create(
    clockid = <INTEGER>,
    sevp = {
        sigev_notify = <opt_notify_methods>,
        ..
    },
    timerid
);

// Retrieve or set the parent-death signal
prctl(op = PR_GET_PDEATHSIG | PR_SET_PDEATHSIG, sig);

// Get or set the name of calling thread
prctl(op = PR_GET_NAME | PR_SET_NAME, name);

// Query whether process retains permitted capabilities after `UID` changes
prctl(op = PR_GET_KEEPCAPS);

// Configure permitted capabilities retention after `UID` changes
prctl(op = PR_SET_KEEPCAPS, state);

// Retrieve or set "child subreaper" attribute
prctl(op = PR_GET_CHILD_SUBREAPER | PR_SET_CHILD_SUBREAPER, isset);

// Get capabilities of thread
capget(
    hdrp = {
        version = _LINUX_CAPABILITY_VERSION_3,
        ..
    },
    datap
);

// Set capabilities of thread
capset(
    hdrp = {
        version = _LINUX_CAPABILITY_VERSION_3,
        ..
    },
    datap
);

predefined_clockid = CLOCK_REALTIME | CLOCK_MONOTONIC | CLOCK_MONOTONIC_RAW |
                     CLOCK_REALTIME_COARSE | CLOCK_MONOTONIC_COARSE | CLOCK_BOOTTIME |
                     CLOCK_PROCESS_CPUTIME_ID | CLOCK_THREAD_CPUTIME_ID;

// Get the time of a clock specified by a static ID
clock_gettime(clockid = <predefined_clockid>, tp);

// Get the time of a clock specified by a dynamic ID
clock_gettime(clockid = <INTEGER>, tp);

// Sleep with a specified clock
clock_nanosleep(
    clockid = CLOCK_REALTIME | CLOCK_MONOTONIC | CLOCK_BOOTTIME | CLOCK_PROCESS_CPUTIME_ID,
    flags =
        // Optional flags:
        //
        // Sleep until an absolute time point
        TIMER_ABSTIME,
    t, remain
);

// Get or set the FS register
arch_prctl(
    code = ARCH_GET_FS | ARCH_SET_FS,
    addr
);

// Return resource usage statistics for the calling process
getrusage(
    who = RUSAGE_SELF,
    usage
);

// Return resource usage statistics for the calling thread
getrusage(
    who = RUSAGE_THREAD,
    usage
);

// Obtain random bytes
getrandom(
    buf, buflen,
    flags =
        // Optional flags:
        //
        // High-entropy pool
        GRND_RANDOM
);

// Set file offset
lseek(
    fd, offset,
    whence = SEEK_SET | SEEK_CUR | SEEK_END
);

// Retrieve file status by file descriptor
newfstatat(
    dirfd, path, statbuf,
    flags = AT_EMPTY_PATH | AT_SYMLINK_NOFOLLOW
);

opt_flags = FUTEX_PRIVATE_FLAG | FUTEX_CLOCK_REALTIME;

// Block current thread if target value at `uaddr` matches `val`
futex(
    uaddr,
    futex_op = FUTEX_WAIT | <opt_flags>,
    val, timeout
);

// Block current thread with bitmask condition if target value at `uaddr` matches `val`
futex(
    uaddr,
    futex_op = FUTEX_WAIT_BITSET | <opt_flags>,
    val, timeout, uaddr2 = NULL, val3
);

// Unblock up to `val` threads waiting on `uaddr`
futex(
    uaddr,
    futex_op = FUTEX_WAKE | <opt_flags>,
    val
);

// Unblock threads matching bitmask, up to `val` waiters
futex(
    uaddr,
    futex_op = FUTEX_WAKE_BITSET | <opt_flags>,
    val, timeout, uaddr2 = NULL, val3
);

// Transfer `val` waiters to another wait queue
futex(
    uaddr,
    futex_op = FUTEX_REQUEUE | <opt_flags>,
    val, val2, uaddr2
);

// Wake waiters after atomic operation on `uaddr2`
futex(
    uaddr,
    futex_op = FUTEX_WAKE_OP | <opt_flags>,
        futex_op = FUTEX_WAIT | opt_flags,
    val, timeout
);

// Block current thread with bitmask condition if target value at `uaddr` matches `val`
futex(
    uaddr,
    futex_op = FUTEX_WAIT_BITSET | opt_flags,
    val, timeout, uaddr2 = NULL, val3
);

// Unblock up to `val` threads waiting on `uaddr`
futex(
    uaddr,
    futex_op = FUTEX_WAKE | opt_flags,
    val
);

// Unblock threads matching bitmask, up to `val` waiters
futex(
    uaddr,
    futex_op = FUTEX_WAKE_BITSET | opt_flags,
    val, timeout, uaddr2 = NULL, val3
);

// Transfer `val` waiters to another wait queue
futex(
    uaddr,
    futex_op = FUTEX_REQUEUE | opt_flags,
    val, val2, uaddr2
);

// Wake waiters after atomic operation on `uaddr2`
futex(
    uaddr,
    futex_op = FUTEX_WAKE_OP | opt_flags,
    val, val2, uaddr2, val3
);

// Create a pair of connected UNIX sockets
socketpair(
    family = AF_UNIX,
    type = SOCK_STREAM | SOCK_SEQPACKET | <opt_type_flags>,
    protocol = 0,
    sv
);

struct sockaddr = {
    sa_family = AF_INET | AF_UNIX | AF_NETLINK | AF_VSOCK,
    ..
};

// Bind a socket to an address
bind(
    sockfd, addr = <sockaddr>, addrlen
);

// Connect to a peer socket
connect(
    sockfd, addr = <sockaddr>, addrlen
);

// Send message on a socket
sendto(
    sockfd, buf, len,
    flags = 0,
    dest_addr = <sockaddr>,
    addrlen
);

// Send message using scatter-gather buffers and ancillary data
sendmsg(
    sockfd,
    msg = {
        msg_name = <sockaddr>,
        msg_control = NULL,
        ..
    },
    flags = 0
);

// Receive message from a socket
recvfrom(
    sockfd, buf, size,
    flags = 0,
    src_addr, addrlen
);

// Receive message using scatter-gather buffers and ancillary data
recvmsg(
    sockfd,
    msg,
    flags = 0
);

socket_options = SO_SNDBUF | SO_RCVBUF | SO_REUSEADDR | SO_REUSEPORT |
                 SO_PRIORITY | SO_LINGER | SO_PASSCRED | SO_KEEPALIVE |
                 SO_SNDBUFFORCE | SO_RCVBUFFORCE | SO_ERROR |
                 SO_PEERCRED | SO_ACCEPTCONN | SO_PEERGROUPS;

ip_options = IP_TOS | IP_TTL | IP_HDRINCL;

tcp_options = TCP_NODELAY | TCP_MAXSEG | TCP_KEEPIDLE | TCP_SYNCNT |
              TCP_DEFER_ACCEPT | TCP_WINDOW_CLAMP | TCP_CONGESTION |
              TCP_USER_TIMEOUT | TCP_INQ;

// Get options at socket level
getsockopt(
    sockfd, level = SOL_SOCKET,
    optname = <socket_options>,
    optval, optlen
);

// Get options at IP level
getsockopt(
    sockfd, level = SOL_IP,
    optname = <ip_options>,
    optval, optlen
);

// Get options at TCP level
getsockopt(
    sockfd, level = SOL_TCP,
    optname = <tcp_options>,
    optval, optlen
);

// Set options at socket level
setsockopt(
    sockfd, level = SOL_SOCKET,
    optname = <socket_options>,
    optval, optlen
);

// Set options at IP level
setsockopt(
    sockfd, level = SOL_IP,
    optname = <ip_options>,
    optval, optlen
);

// Set options at TCP level
setsockopt(
    sockfd, level = SOL_TCP,
    optname = <tcp_options>,
    optval, optlen
);

// Set options at netlink level
setsockopt(
    sockfd, level = SOL_NETLINK,
    optname = NETLINK_ADD_MEMBERSHIP | NETLINK_DROP_MEMBERSHIP,
    optval, optlen
);

// Check user's permissions for a file
access(pathname, mode);

// Set an alarm clock for delivery of a signal
alarm(seconds);

// Change data segment size
brk(addr);

// Close a file descriptor
close(fd);

// Duplicate a file descriptor
dup(oldfd);
dup2(oldfd, newfd);
dup3(oldfd, newfd, flags = O_CLOEXEC);

// Execute program
execve(pathname, argv, envp);

// Exit all threads in a process
exit_group(status);

// Get file status
stat(pathname, statbuf);
lstat(pathname, statbuf);
fstat(fd, statbuf);

// Get group identity
getegid();

// Get user identity
getuid();
geteuid();

// Get group identity
getgid();

// Get socket name
getsockname(sockfd, addr, addrlen);

// Create a directory
mkdir(pathname, mode);

// Read from a file descriptor
read(fd, buf, count);

// Return from signal handler and cleanup stack frame
rt_sigreturn(arg);

// Set and get a thread's CPU affinity mask
sched_getaffinity(pid, cpusetsize, mask);

// Set list of robust futexes
set_robust_list(head, len);

// Set pointer to thread ID
set_tid_address(tidptr);

// Set user identity
setuid(uid);

// Write to a file descriptor
write(fd, buf, count);

// Return system information
sysinfo(info);

// Get process identification
getpid();
getppid();

// Read from a file descriptor at a given offset
pread64(fd, buf, count, offset);

// Get directory entries
getdents64(fd, dirp, count);

// Monitor multiplexed I/O with signal safety and precise timeout handling
pselect6(nfds, readfds, writefds, exceptfds, timeout, sigmask);

// Get or set resource limits
prlimit64(pid, resource, new_limit, old_limit);

// Wait until a specified child process undergoes a state change (termination, stopping and resumption)
wait4(
    pid, wstatus,
    options = WNOHANG | WSTOPPED | WCONTINUED | WNOWAIT,
    rusage
);

signal_flags = SIGHUP | SIGINT | SIGQUIT | SIGILL |
               SIGTRAP | SIGABRT | SIGSTKFLT | SIGFPE |
               SIGKILL | SIGBUS | SIGSEGV | SIGXCPU |
               SIGPIPE | SIGALRM | SIGTERM | SIGUSR1 |
               SIGUSR2 | SIGCHLD | SIGPWR | SIGVTALRM |
               SIGPROF | SIGIO | SIGWINCH | SIGSTOP |
               SIGTSTP | SIGCONT | SIGTTIN | SIGTTOU |
               SIGURG | SIGXFSZ | SIGSYS | SIGRTMIN;

opt_flags =
    // Optional flags
    //
    // Share the parent's virtual memory
    CLONE_VM |
    // Share the parent's filesystem
    CLONE_FS |
    // Share the parent's file descriptor table
    CLONE_FILES |
    // Share the parent's signal handlers
    CLONE_SIGHAND |
    // Place child in the same thread group as parent
    CLONE_THREAD |
    // Share the parent's System V semaphore adjustments
    CLONE_SYSVSEM |
    // Suspend parent until the child exits or calls `execve`
    CLONE_VFORK |
    // Create a new mount namespace for the child
    CLONE_NEWNS |
    // Write child `TID` to parent's memory
    CLONE_PARENT_SETTID |
    // Allocate a `PID` file descriptor for the child
    CLONE_PIDFD |
    // Set thread-local storage for the child
    CLONE_SETTLS |
    // Write child `TID` to child's memory
    CLONE_CHILD_SETTID |
    // Clear child `TID` in child's memory on exit
    CLONE_CHILD_CLEARTID |
    // Make the child's parent the same as the caller's parent
    CLONE_PARENT;

// Create a thread or process
clone(
    fn, stack,
    flags = <opt_flags> | <signal_flags>,
    func_arg, ..
);

poll(fds, nfds, timeout);
